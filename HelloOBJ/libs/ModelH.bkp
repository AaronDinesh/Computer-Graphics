#ifndef MODEL_CLASS_H
#define MODEL_CLASS_H

#include <glm/glm.hpp>
#include <vector>
#include <fstream>
#include <glad.h>
#include <string.h>
#include <cerrno>
#include <iostream>
#include <nlohmann/json.hpp>

#include "Mesh.h"


/*
OBJ file format

v x y z     -> This specifies one of the vertexes of the object in xyz coords
vt u v [w]  -> This specifies the texture coordinates for a vertex
vn x y z    -> This specifies the vertex normal
f v1 v2 v3  -> This specifies the index of the vertices used to make this face.
               The index starts at 1
*/



/*
errVal is an indicator of what went wrong during Model Loading
*/

typedef enum errval{SUCCESS, WRONG_FILE_TYPE, 
                    JSON_PARSE_ERROR, BINARY_READ_ERROR} err;


class Model{
    public:
        Model(const char* path);

        void Draw(Shader& shader, Camera& camera);

    private:
        void loadMesh(unsigned int indMesh);

        const char* filePath = NULL;

        std::vector<Mesh> meshes;
        std::vector<glm::vec3> translationsMeshes;
	    std::vector<glm::quat> rotationsMeshes;
	    std::vector<glm::vec3> scalesMeshes;
	    std::vector<glm::mat4> matricesMeshes;


        //gltf parser functions
        nlohmann::json gltfFile;
        // Prevents textures from being loaded twice
	    std::vector<std::string> loadedTexName;
	    std::vector<Texture> loadedTex;
        std::vector<unsigned char> data;

        std::vector<unsigned char> getBinaryData();

        std::vector<float> getFloats(nlohmann::json accessor);
        std::vector<GLuint> getIndices(nlohmann::json accessor);

        std::vector<glm::vec2> groupFloatsVec2(std::vector<float> floatVec);
        std::vector<glm::vec3> groupFloatsVec3(std::vector<float> floatVec);
        std::vector<glm::vec4> groupFloatsVec4(std::vector<float> floatVec);

        std::vector<Texture> getTextures();
        std::vector<Vertex> assembleVertices(std::vector<glm::vec3> positions, std::vector<glm::vec3> normals, std::vector<glm::vec2> texUVs);

        // Traverses a node recursively, so it essentially traverses all connected nodes
	    void traverseNode(unsigned int nextNode, glm::mat4 matrix = glm::mat4(1.0f));

};
#endif